clear all
close all

%% Parametri
MPAM = 2; 
nbits = 1e4; % Numero di bit trasmessi
Mbps = 100; % Velocità di trasmissione in Mbps
fs = 16000; % Banda di simulazione (freq di campionamento)

BpS = log2(MPAM); % Numero di bits per simbolo
Rs = Mbps/BpS; % Velocità di trasmissione simboli in Baud
SpS = fs/Rs; % Campioni per simbolo
Ts = 1/Rs; % Tempo di trasmissione di un simbolo
Tc = 1/fs;
sym2alpha = [0;1]; % Tabella di conversione da simboli a coefficienti PAM
alpha2sym = [0;1]; % Tabella di conversione da coefficienti PAM a simboli
CarrierFreq = 2e3; % Frequenza carrier sinusoidale

%% Funzioni di utilità

% Converte un segnale elettrico in bits
function bits = toBits(sig, sym2alpha, alpha2sym, SpS)
bits = [];

% Creazione delle soglie 
th = [];
for i=1:length(sym2alpha)-1
    th = [th, (sym2alpha(i+1)+sym2alpha(i))/2]; 
end

% Comprime il segnale a 1 SpS
alphas = []; % Coefficienti
for i=0:length(sig)/SpS-1
    alphas = [alphas sig(i*SpS+ceil(SpS/2))];
end

% Converte i coefficienti in simboli
for i=1:length(alphas)
    for j=1:length(th)
        sym = alpha2sym(j+1, :);
        if(abs(alphas(i)) <= th(j)) 
            sym = alpha2sym(j, :);
            break;
        end
    end
    bits = [bits, sym];
end
end

% Calcola la BER tra segnale entrante e segnale uscente
function BER = ber(bits_in, bits_out)
t = abs(bits_in-bits_out); % Calcola i bits di differenza tra i due segnali
BER = sum(t)/length(t);
end

% Applica un passa-basso di frequenza ff
function sig = lowPass(sig_in, fs, ff) 
    f = linspace(-fs/2, +fs/2, length(sig_in));
    Sig = fftshift(fft(sig_in));
    for i=1:length(Sig)
        if(abs(f(i))>ff)
            Sig(i) = 0;
        end
    end
    sig = ifft(fftshift(Sig));
end

% Filtra il segnale con il filtro passato come parametro
function sig_out = sigFilter(sig, filter) 
Sig_in = fft(sig);
Sig_out = Sig_in.*fftshift(filter);
sig_out = real(ifft(Sig_out));
end

